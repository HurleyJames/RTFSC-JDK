---
title: java.lang 包
---

# java.lang 包

[[toc]]

## Object类

`Object`类是 Java 类的共同祖先，我们使用到的 Java 的所有的类都可以说是继承至了`Object`类。

```java
// 返回当前对象所属的类对象
public final native Class<?> getClass();

// 返回当前对象的哈希值，哈希值往往是作为当前对象的唯一标识
public native int hashCode();

// 判断是否相等，其实是简单地比较两个对象的引用是否相等
// 那么可以引申出，equals() 与 == 的区别
public boolean equals(Object obj) {
    return (this == obj);
}

// 将一个类型字符串化，通过我们需要重写这个方法
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}

// 这个 clone 方法是实现浅拷贝，使用时会经常需要被重写，改为 public 方法
// 注意，要求被克隆的对象所属的类必须实现 Cloneable 接口
protected native Object clone() throws ClongNotSupportedException;

// 这个方法是对象在被垃圾回收器回收之后执行的清理操作。
// 但是因为这个方法可能会引起 OOM，所以在JDK9版本之后已经废弃，建议使用 java.lang.ref.Cleaner 来代替
protected void finalize() throws Throwable {
}

// 随机唤醒某个具有相同锁的对象，从wait状态进入争夺锁的状态
public final native void notify();

// 唤醒所有具有相同锁的对象，从wait状态进入争夺锁的状态
public final native void notifyAll();
```

这个类中列出的一些方法都是在Java类中都可以使用到的方法（如果您的 IntelliJ IDEA 中有代码自动提示，您应该能感受到）。除此之外，还要一个重要的方法是下面的`wait()`方法：

```java
// wait 方法是使调用 wait 方法的线程放弃锁的持有权，并且进入 WAITING 或者 TIMED_WAITING 的状态
// wait 方法应该要调用synchronized一起使用
// wait 线程醒来的条件是：
// 1. 超时
// 2. 被 notify() 或者 notifyAll() 唤醒
// 3. 在其它线程中调用该线程的 interrupt() 方法

// wait 方法持有的锁是当前 wait 所处的上下文的对象。
// 如果 wait 持有的锁和当前上下文的锁不一致，或者 wait 和 notify 的锁也不一致，就会触发 InterruptedException

// 这个方法中并不含有参数，所以是一个永不超时的方法，只有上面的条件 2 或 3 能够唤醒
public final void wait() throws InterruptedException {
    wait(0L);
}

// 上面那个方法的实现就是通过下面这个方法，即等待 timeoutMillis 毫秒之后会自动醒来，当然也可以通过上述条件 2 或 3 来唤醒
public final native void wait(long timeoutMillis) throws InterruptedException;

// 除此之外，还可以使用下面这个方法
// 这意味着至少需要等待 timeoutMillis 毫秒，nanos 是一个纳秒级的附加时间，是用来微调 timeoutMillis 参数的（释放锁）
// 内部实现可以参考T hread 类中的 void sleep(long millis, int nanos)方 法
public final void wait(long timeoutMillis, int nanos) throws InterruptedException {
    if (timeoutMillis < 0) {
        throw new IllegalArgumentException("timeoutMillis value is negative");
    }
    if (nanos < 0 || nanos > 999999) {
        throw new IllegalArgumentException("nanosecond timeout value out of range");
    }
    if (nanos > 0) {
        timeoutMillis++;
    }
    wait(timeoutMillis);
}
```

上面的代码中我们会发现有一个特点，就是凡是用`native`修饰符修饰的方法，里面都并没有具体的方法实现内容。要知道，这个类可是所有类的父类，它不是一个抽象类，也不是一个接口，那么它定义的方法怎么可能不去实现呢？

这一切都是通过`native`来实现。当使用这个修饰符来修饰某个方法时，这就代表着该方法的实现并非通过 Java 语言来实现，即这个一个 Java 调用非 Java 代码的接口。因为 Java 无法直接访问到操作系统的底层（如系统硬件等），所以 Java 就得使用`native`方法来扩展 Java 程序的功能。

`native`方法是通过 Java 中的 JNI 实现的，JNI 就是 Java Native Interface 的缩写。从 Java 1.1 版本之后，JNI 就已经成为了 Java 平台的一部分，它允许 Java 代码和其它语言编写的代码进行交互。

## String类

## AbstractStringBuilder类

## StringBuffer类

## StringBuilder类

## Boolean类

## Byte类

## Double类

## Float类

## Short类

## Thread类

## ThreadLocal类

## Enum类

## Throwable类

## Error类

## Exception类

## Class类

## ClassLoader类

## Compiler类

## System类

## Package类

## Void类