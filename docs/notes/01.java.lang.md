---
title: java.lang包
---

# java.lang包

[[toc]]

## Object类

`Object`类是Java类的共同祖先，我们使用到的Java的所有的类都可以说是继承至了`Object`类。

```java
// 返回当前对象所属的类对象
public final native Class<?> getClass();

// 返回当前对象的哈希值，哈希值往往是作为当前对象的唯一标识
public native int hashCode();

// 判断是否相等，其实是简单地比较两个对象的引用是否相等
// 那么可以引申出，equals()与==的区别
public boolean equals(Object obj) {
    return (this == obj);
}

// 将一个类型字符串化，通过我们需要重写这个方法
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}

// 这个clone方法是实现浅拷贝，使用时会经常需要被重写，改为public方法
// 注意，要求被克隆的对象所属的类必须实现Cloneable接口
protected native Object clone() throws ClongNotSupportedException;

// 这个方法是对象在被垃圾回收器回收之后执行的清理操作。
// 但是因为这个方法可能会引起OOM，所以在JDK9版本之后已经废弃，建议使用java.lang.ref.Cleaner来代替
protected void finalize() throws Throwable {
}

// 随机唤醒某个具有相同锁的对象，从wait状态进入争夺锁的状态
public final native void notify();

// 唤醒所有具有相同锁的对象，从wait状态进入争夺锁的状态
public final native void notifyAll();
```

这个类中列出的一些方法都是在Java类中都可以使用到的方法（如果您的IntelliJ IDEA中有代码自动提示，您应该能感受到）。除此之外，还要一个重要的方法是下面的`wait()`方法：

```java
// wait方法是使调用wait方法的线程放弃锁的持有权，并且进入WAITING或者TIMED_WAITING的状态
// wait方法应该要调用synchronized一起使用
// wait线程醒来的条件是：
// 1. 超时
// 2. 被notify()或者notifyAll()唤醒
// 3. 在其它线程中调用该线程的interrupt()方法

// wait方法持有的锁是当前wait所处的上下文的对象。
// 如果wait持有的锁和当前上下文的锁不一致，或者wait和notify的锁也不一致，就会触发InterruptedException

// 这个方法中并不含有参数，所以是一个永不超时的方法，只有上面的条件2或3能够唤醒
public final void wait() throws InterruptedException {
    wait(0L);
}

// 上面那个方法的实现就是通过下面这个方法，即等待timeoutMillis毫秒之后会自动醒来，当然也可以通过上述条件2或3来唤醒
public final native void wait(long timeoutMillis) throws InterruptedException;

// 除此之外，还可以使用下面这个方法
// 这意味着至少需要等待timeoutMillis毫秒，nanos是一个纳秒级的附加时间，是用来微调timeoutMillis参数的（释放锁）
// 内部实现可以参考Thread类中的void sleep(long millis, int nanos)方法
public final void wait(long timeoutMillis, int nanos) throws InterruptedException {
    if (timeoutMillis < 0) {
        throw new IllegalArgumentException("timeoutMillis value is negative");
    }
    if (nanos < 0 || nanos > 999999) {
        throw new IllegalArgumentException("nanosecond timeout value out of range");
    }
    if (nanos > 0) {
        timeoutMillis++;
    }
    wait(timeoutMillis);
}
```

上面的代码中我们会发现有一个特点，就是凡是用`native`修饰符修饰的方法，里面都并没有具体的方法实现内容。要知道，这个类可是所有类的父类，它不是一个抽象类，也不是一个接口，那么它定义的方法怎么可能不去实现呢？

这一切都是通过`native`来实现。当使用这个修饰符来修饰某个方法时，这就代表着该方法的实现并非通过Java语言来实现，即这个一个Java调用非Java代码的接口。因为Java无法直接访问到操作系统的底层（如系统硬件等），所以Java就得使用`native`方法来扩展Java程序的功能。

`native`方法是通过Java中的JNI实现的，JNI就是Java Native Interface的缩写。从Java1.1版本之后，JNI就已经成为了Java平台的一部分，它允许Java代码和其它语言编写的代码进行交互。

## String类

## AbstractStringBuilder类

## StringBuffer类

## StringBuilder类

## Boolean类

## Byte类

## Double类

## Float类

## Short类

## Thread类

## ThreadLocal类

## Enum类

## Throwable类

## Error类

## Exception类

## Class类

## ClassLoader类

## Compiler类

## System类

## Package类

## Void类